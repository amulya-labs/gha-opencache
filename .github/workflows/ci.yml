name: CI

on:
  push:
    branches: [main]
  pull_request:
    branches: [main]

permissions:
  contents: read

jobs:
  validate:
    name: Validate Examples & Docs
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683  # v4.2.2

      - name: Download actionlint
        run: |
          set -euo pipefail

          ACTIONLINT_VERSION="1.7.10"
          ACTIONLINT_OS="linux"
          ACTIONLINT_ARCH="amd64"

          TARBALL="actionlint_${ACTIONLINT_VERSION}_${ACTIONLINT_OS}_${ACTIONLINT_ARCH}.tar.gz"
          CHECKSUMS_FILE="actionlint_${ACTIONLINT_VERSION}_checksums.txt"
          BASE_URL="https://github.com/rhysd/actionlint/releases/download/v${ACTIONLINT_VERSION}"

          echo "Downloading actionlint ${ACTIONLINT_VERSION}..."
          curl -sSL "${BASE_URL}/${TARBALL}" -o "${TARBALL}"
          curl -sSL "${BASE_URL}/${CHECKSUMS_FILE}" -o "${CHECKSUMS_FILE}"

          echo "Verifying checksum..."
          grep "${TARBALL}" "${CHECKSUMS_FILE}" | sha256sum -c -

          echo "Extracting actionlint..."
          mkdir -p /tmp/actionlint-bin
          tar -xzf "${TARBALL}" -C /tmp/actionlint-bin

          echo "/tmp/actionlint-bin" >> "$GITHUB_PATH"

      - name: Validate example workflows
        run: |
          set -e
          echo "Validating example workflows..."

          example_count=0
          error_count=0

          for file in examples/*.yml; do
            echo ""
            echo "=== Validating: $file ==="
            example_count=$((example_count + 1))

            if actionlint "$file"; then
              echo "✅ $file is valid"
            else
              echo "❌ $file has errors"
              error_count=$((error_count + 1))
            fi
          done

          echo ""
          echo "======================================"
          echo "Validated $example_count example files"

          if [ $error_count -gt 0 ]; then
            echo "❌ $error_count file(s) with errors"
            exit 1
          else
            echo "✅ All examples are valid!"
          fi

      - name: Check for common issues
        run: |
          set -e
          echo "Checking for common issues in examples..."

          # Fail if any gha-opencache @v1 references are present
          if grep -r "amulya-labs/gha-opencache@v1" examples/ --include="*.yml"; then
            echo ""
            echo "❌ Error: Found gha-opencache @v1 references in examples"
            echo "All examples must use @v2; please update these references."
            exit 1
          fi

          echo "✅ No common issues found"

      - name: Validate example consistency
        run: |
          echo "Checking example consistency..."

          for file in examples/*.yml; do
            if ! grep -q "^name:" "$file"; then
              echo "❌ $file: Missing 'name:' field"
              exit 1
            fi
          done

          echo "✅ All examples have required fields"

      - name: Validate YAML syntax in markdown files
        run: |
          set -e
          echo "Validating YAML blocks in markdown files..."

          pip install pyyaml --quiet

          cat > /tmp/validate_md_yaml.py << 'PYTHON_SCRIPT'
          import re
          import sys
          import yaml
          from pathlib import Path

          def extract_yaml_blocks(md_content):
              """Extract YAML code blocks from markdown"""
              pattern = r'```ya?ml[^\n]*\n(.*?)\n```'
              blocks = re.findall(pattern, md_content, re.DOTALL)
              return blocks

          def validate_yaml_block(yaml_content, source, block_num):
              """Validate YAML syntax"""
              if '\n' not in yaml_content.strip():
                  return True, None  # Single line = snippet, skip validation

              try:
                  yaml.safe_load(yaml_content)
                  return True, None
              except yaml.YAMLError as e:
                  return False, str(e)

          md_files = list(Path('.').rglob('*.md'))
          md_files = [f for f in md_files if 'node_modules' not in str(f) and '.claude' not in str(f)]

          total_blocks = 0
          error_count = 0

          for md_file in md_files:
              content = md_file.read_text()
              blocks = extract_yaml_blocks(content)

              if blocks:
                  print(f"\n=== {md_file} ===")
                  print(f"  Found {len(blocks)} YAML block(s)")
                  total_blocks += len(blocks)

                  for i, block in enumerate(blocks, 1):
                      valid, error = validate_yaml_block(block, md_file, i)
                      if valid:
                          print(f"  Block {i}: ✅ Valid YAML syntax")
                      else:
                          print(f"  Block {i}: ❌ Invalid YAML")
                          print(f"    Error: {error}")
                          error_count += 1

          print(f"\n{'='*50}")
          print(f"Total YAML blocks validated: {total_blocks}")
          if error_count > 0:
              print(f"❌ {error_count} block(s) with YAML syntax errors")
              print(f"Note: Single-line snippets are skipped automatically")
              sys.exit(1)
          else:
              print(f"✅ All YAML blocks have valid syntax")
          PYTHON_SCRIPT

          python3 /tmp/validate_md_yaml.py

  s3-integration:
    name: S3 Integration Tests
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683  # v4.2.2

      - name: Setup Node.js
        uses: actions/setup-node@1d0ff469b7ec7b3cb9d8673fde0c81c44821de2a  # v4.2.0
        with:
          node-version: '20'
          cache: 'npm'

      - name: Start MinIO
        run: |
          docker run -d --rm \
            --name minio \
            -p 9000:9000 \
            -e MINIO_ROOT_USER=minioadmin \
            -e MINIO_ROOT_PASSWORD=minioadmin \
            quay.io/minio/minio:latest \
            server /data

          # Wait for MinIO to be ready
          echo "Waiting for MinIO to start..."
          minio_ready=0
          for i in {1..30}; do
            if curl -sf http://localhost:9000/minio/health/live; then
              echo "MinIO is ready"
              minio_ready=1
              break
            fi
            echo "Attempt $i: MinIO not ready yet..."
            sleep 1
          done

          if [ "$minio_ready" -ne 1 ]; then
            echo "ERROR: MinIO failed to become ready after 30 attempts. Exiting workflow."
            docker logs minio || true
            exit 1
          fi

      - name: Install dependencies
        run: npm ci

      - name: Build
        run: npm run build

      - name: Run S3 Integration Tests
        run: npm run test:s3
        env:
          MINIO_ENDPOINT: http://localhost:9000
          MINIO_ACCESS_KEY: minioadmin
          MINIO_SECRET_KEY: minioadmin

      - name: Show MinIO logs on failure
        if: failure()
        run: docker logs minio || true

      - name: Stop MinIO
        if: always()
        run: docker stop minio || true

  build:
    needs: [validate]
    runs-on: ubuntu-latest
    strategy:
      fail-fast: false
      matrix:
        node-version: ['20.x', '22.x']
    steps:
      - name: Checkout
        uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683  # v4.2.2

      - name: Setup Node.js
        uses: actions/setup-node@1d0ff469b7ec7b3cb9d8673fde0c81c44821de2a  # v4.2.0
        with:
          node-version: ${{ matrix.node-version }}
          cache: 'npm'

      - name: Install dependencies
        run: npm ci

      - name: Build
        run: npm run build

      - name: Lint
        run: npm run lint

      - name: Format check
        run: npm run format:check

      - name: Test
        run: npm run test:coverage

      - name: Upload coverage to Codecov
        uses: codecov/codecov-action@0f8570b1a125f4937846a11fcfa3bcd548bd8c97  # v4.6.0
        with:
          files: ./coverage/lcov.info
          flags: unittests
          name: node-${{ matrix.node-version }}
          fail_ci_if_error: false

      - name: Package
        run: npm run package

      - name: Verify dist
        run: |
          if [ ! -f dist/restore/index.js ]; then
            echo "dist/restore/index.js not found"
            exit 1
          fi
          if [ ! -f dist/save/index.js ]; then
            echo "dist/save/index.js not found"
            exit 1
          fi
          if [ ! -f dist/restore-only/index.js ]; then
            echo "dist/restore-only/index.js not found"
            exit 1
          fi
          if [ ! -f dist/save-only/index.js ]; then
            echo "dist/save-only/index.js not found"
            exit 1
          fi
          echo "All dist files present"

  test-action:
    needs: [s3-integration]
    strategy:
      fail-fast: false
      matrix:
        os: [ubuntu-latest, macos-latest, windows-latest]
    runs-on: ${{ matrix.os }}
    steps:
      - name: Checkout
        uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683  # v4.2.2

      - name: Setup Node.js
        uses: actions/setup-node@1d0ff469b7ec7b3cb9d8673fde0c81c44821de2a  # v4.2.0
        with:
          node-version: '20'
          cache: 'npm'

      - name: Install and build
        run: |
          npm ci
          npm run build
          npm run package

      - name: Create test files
        run: |
          mkdir -p test-cache-dir
          echo "test content ${{ github.run_id }}" > test-cache-dir/test.txt
        shell: bash

      - name: Set cache path
        id: cache-path
        run: |
          if [ "${{ runner.os }}" = "Windows" ]; then
            echo "path=${{ runner.temp }}/gha-cache-test" >> $GITHUB_OUTPUT
          else
            echo "path=/tmp/gha-cache-test" >> $GITHUB_OUTPUT
          fi
        shell: bash

      - name: Test save action
        uses: ./save
        with:
          key: test-${{ matrix.os }}-${{ github.run_id }}
          path: test-cache-dir
          cache-path: ${{ steps.cache-path.outputs.path }}

      - name: Remove test files
        run: rm -rf test-cache-dir
        shell: bash

      - name: Test restore action
        id: restore
        uses: ./restore
        with:
          key: test-${{ matrix.os }}-${{ github.run_id }}
          path: test-cache-dir
          cache-path: ${{ steps.cache-path.outputs.path }}

      - name: Verify restore
        run: |
          if [ ! -f test-cache-dir/test.txt ]; then
            echo "Cache restore failed - file not found"
            exit 1
          fi
          echo "Cache restore successful"
          cat test-cache-dir/test.txt
        shell: bash

      - name: Verify cache hit
        run: |
          if [ "${{ steps.restore.outputs.cache-hit }}" != "true" ]; then
            echo "Expected cache-hit to be true"
            exit 1
          fi
          echo "Cache hit verified"
        shell: bash

      - name: Test compression options (gzip)
        run: |
          mkdir -p test-gzip-dir
          echo "gzip test ${{ github.run_id }}" > test-gzip-dir/test.txt
        shell: bash

      - name: Save with gzip compression
        uses: ./save
        with:
          key: test-gzip-${{ matrix.os }}-${{ github.run_id }}
          path: test-gzip-dir
          cache-path: ${{ steps.cache-path.outputs.path }}
          compression: gzip
          compression-level: '9'

      - name: Remove gzip test files
        run: rm -rf test-gzip-dir
        shell: bash

      - name: Restore gzip cache
        id: restore-gzip
        uses: ./restore
        with:
          key: test-gzip-${{ matrix.os }}-${{ github.run_id }}
          path: test-gzip-dir
          cache-path: ${{ steps.cache-path.outputs.path }}

      - name: Verify gzip restore
        run: |
          if [ ! -f test-gzip-dir/test.txt ]; then
            echo "Gzip cache restore failed"
            exit 1
          fi
          echo "Gzip cache restore successful"
        shell: bash

  ci-success:
    name: CI Success
    needs: [validate, s3-integration, build, test-action]
    runs-on: ubuntu-latest
    if: always()
    steps:
      - name: Check all jobs status
        run: |
          echo "Validate: ${{ needs.validate.result }}"
          echo "S3 Integration: ${{ needs.s3-integration.result }}"
          echo "Build: ${{ needs.build.result }}"
          echo "Test action: ${{ needs.test-action.result }}"

          # Validate must succeed
          if [ "${{ needs.validate.result }}" == "failure" ] || [ "${{ needs.validate.result }}" == "cancelled" ]; then
            echo "❌ Validation failed or was cancelled"
            exit 1
          fi
          echo "✅ Validation passed"

          # S3 Integration must succeed
          if [ "${{ needs.s3-integration.result }}" == "failure" ] || [ "${{ needs.s3-integration.result }}" == "cancelled" ]; then
            echo "❌ S3 Integration tests failed or was cancelled"
            exit 1
          fi
          echo "✅ S3 Integration tests passed"

          # Build must succeed
          if [ "${{ needs.build.result }}" == "failure" ] || [ "${{ needs.build.result }}" == "cancelled" ]; then
            echo "❌ Build failed or was cancelled"
            exit 1
          fi
          echo "✅ Build passed"

          # Test action must succeed (matrix job)
          if [ "${{ needs.test-action.result }}" == "failure" ] || [ "${{ needs.test-action.result }}" == "cancelled" ]; then
            echo "❌ Test action failed or was cancelled"
            exit 1
          fi
          echo "✅ Test action passed"

          echo "✅ All CI jobs passed successfully!"
